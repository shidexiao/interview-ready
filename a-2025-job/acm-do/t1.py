'''
一线运维人员在对通话流量进行监控，每一段时间内都会出现流量的高峰，流量有高有低形成一个个波峰波谷，
运维人员想找到流量变化最快的波峰，你可以帮助他吗？

给定一个整数数组nums，代表采样点的流量值，请找到满足以下条件的三元组（i,j,K）： 其中i<j<k,nums[j]>nums[i]且nums[j]>nums[k]（即j是峰顶），并找到所有满足
条件的三元组中（k-i）的最小值
丿输入描述
第一行为n个整数，表示数组中的n个元素，0＜=n＜=100000
丿输出描还
返回所有满足条件的三元組中（k-I）的最小值。若不存在，返回-1。

示例1，
输入： 3 5 4 7 2 1
输出：2
说明： 满足条件的三元组：为[0,1,2],距离2

示例2，
输入：4 3 2 1
输出：-1



'''


# ---------- 题目1：单调栈求最近更小元素并取最小区间宽度 ----------
# 功能概述：
#   给定数组 a，计算对于每个位置 i：
#     l[i] = 最近左侧下标 j （j < i）使得 a[j] < a[i]（不存在则为 -1）
#     r[i] = 最近右侧下标 k （k > i）使得 a[k] < a[i]（不存在则为 -1）
#   然后在所有同时存在 l[i] 和 r[i] 的 i 中，求最小的 r[i] - l[i] 并输出该值。
# 算法要点：
#   使用单调栈（保持栈上索引对应的 a 值严格单调递增）来在 O(n) 内求出最近更小元素。
# 复杂度：时间 O(n)，空间 O(n)

a = [int(i) for i in input().split()]  # 读入一行整数
n = len(a)

# l 和 r 分别存最近左侧更小元素索引与最近右侧更小元素索引
l, r = [0] * n, [0] * n

# 计算 l[i]：最近左侧小于 a[i] 的索引
# 用一个单调增栈存储索引，栈底放哨兵 -1（表示没有更小元素）
st = [-1]
for i in range(n):
    # 弹出栈中值 >= 当前值的索引，保持栈中索引对应的值单调递增
    while len(st) > 1 and a[i] <= a[st[-1]]:
        st.pop()
    # 栈顶就是最近左侧更小元素的索引（若为 -1 则无）
    l[i] = st[-1]
    st.append(i)

# 计算 r[i]：最近右侧小于 a[i] 的索引（对数组反向同理）
st = [-1]
for i in range(n - 1, -1, -1):
    while len(st) > 1 and a[i] <= a[st[-1]]:
        st.pop()
    r[i] = st[-1]
    st.append(i)

# 在同时存在左/右更小元素的位置中找最小区间宽度 r[i] - l[i]
ans = -1
for i in range(n):
    # 若某侧不存在更小元素，则跳过（题意需要两侧都有）
    if l[i] == -1 or r[i] == -1:
        continue
    if ans == -1 or ans > r[i] - l[i]:
        ans = r[i] - l[i]

print(ans)
# 第1题，如果面试官问该题的解题思路可说明：
# 我的思路是把每个位置当成峰值，用单调栈在线性时间求出它左边和右边最近的更小元素下标，
# 再在两侧都存在的情况下取 右最近更小 - 左最近更小 的最小值；
# 这里用到的是单调栈找最近更小元素的算法，时间 O(n)、空间 O(n)
#
