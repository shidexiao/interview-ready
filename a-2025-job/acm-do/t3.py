'''
在产品配置中，一个配置产品是由多个产品模块（CM）构成，每个CM有自身的算法，且模块间可能存在算法依赖。例如电脑产品是由主板，CPU，显卡等CM构成，CPU模块（CM1）算法依赖主板模块（CM2）算法，记作CM2<-CM1；算法引擎会通过算法依赖算出前后CM执行的顺序。如果存在模块算法循环依赖的场景，那么算法引擎会报错，如下图所示：

）输入描述
CM2
输入的第一行为模块列表，例收如：CM2,CM3,CM4；输入的第二行为依赖情况，例如：CM3<
丿输出描述
计算出循坏依赖的CM数量
1 示例1
收起～
输入
输出
3
'''

# ---------- 题目3：有向图中找环上节点数（DFS 三色法） ----------
# 功能概述：
#   输入若干有向边，每条形如 "U<-V"（原始字符串示例：CM5<-CM3）
#   将这些关系视为有向边（这里我们把 h[0] -> h[1] 作为边达成图的约定——与输入含义保持一致即可）；

#   求图中属于至少一个环的节点数量（即图中所有落在任一环上的节点数量）。
#
# 算法要点（DFS 三色/递归栈法）：
#   - 用 vis 字典保存状态：0=未访问，1=在递归栈中（正在访问），2=已完成访问
#   - DFS 过程中，若遇到一条指向状态为 1 的节点的边，说明存在回边 => 找到一个环
#   - 通过保存当前递归路径（列表 p），可以把回边形成的环的节点区间提取出来并加入集合 c
#   - 最终 c 的大小就是属于环的节点数
#
# 复杂度：O(V + E)

# 读入形式 "CM5<-CM3,CM4<-CM5,..."，先按逗号分隔
a = input().split(',')

# 构建有向图的邻接表，nodes 集合保存所有节点
m = {}   # 邻接表，m[x] = [y1, y2, ...] 表示从 x 出发可达的节点列表（x -> y）
s = set()
for i in a:
    h = i.split('<-')      # h[0] <- h[1]，这里按现有代码约定建立邻接关系 h[0] -> h[1]
    u, v = h[0], h[1]
    s.add(u)
    s.add(v)
    if u not in m:
        m[u] = [v]
    else:
        m[u].append(v)

# vis 三色标记，c 保存所有在环上的节点
vis = {x: 0 for x in s}  # 0 未访问，1 在递归栈中，2 已访问完成
c = set()                # 收集所有检测到的环上节点

def dfs(x, p):
    """
    参数：
      x - 当前节点
      p - 当前递归路径（列表），表示从某个起点到当前节点之前的路径节点（不包含当前 x）
    过程：
      - 标记 x 为正在访问（1）
     - 遍历 x 可达的每个邻居 y：
          * 若 y 未访问，则递归 dfs(y, p + [x])
          * 若 y 正在访问（vis[y] == 1），发现回边，则从路径中截取从 y 到当前 x 的节点并加入 c
      - 标记 x 为完成访问（2）
    注意：
      p 中不含当前节点 x，本函数中若发现回边到 y，则环节点序列为 p[p.index(y):] + [x]
    """
    vis[x] = 1
    for y in m.get(x, []):
        if vis[y] == 0:
            dfs(y, p + [x])
        elif vis[y] == 1:
            # 发现回边，路径 p 中找到 y 的位置，将从 y 到当前 x 的节点组成环并加入集合
            # 注意：用 p.index(y) 假设 y 一定在 p 中（因为 vis[y] == 1 表示 y 在当前递归栈）
            c.update(p[p.index(y):] + [x])
    vis[x] = 2

# 对每个节点做一次 DFS（若尚未访问）
for i in s:
    if vis[i] == 0:
        dfs(i, [])

# 输出环上节点的个数
print(len(c))
# 第3题，如果面试官问该题的解题思路可说明：
# 这题本质上是一个有向图找环的问题，我用的是DFS三色标记法来检测循环依赖。
# 具体思路是：我先把所有模块和它们的依赖关系构造成一张有向图，比如 A<-B 就代表 A 依赖 B，也就是有一条 B→A 的边。
# 然后对每个节点做深度优先搜索，用三种状态来标记节点：0表示没访问过；1表示正在递归栈里（访问中）；2表示访问完成。
# 在DFS过程中，如果发现从当前节点走到一个状态是1的节点，说明遇到了回边，也就是形成了一个环。
# 我就把这个环上的所有节点都记录下来。
# 最后统计这些节点的数量，就是存在循环依赖的模块数。
# 整体复杂度是O(V+E)，也就是线性级别。