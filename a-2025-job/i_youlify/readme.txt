

就绪队列（Ready Queue）到底是什么
定义：就是一个内存里的队列数据结构（可以是链表、数组、优先队列等），用来存放当前可以立刻运行的协程任务。
在 Python asyncio 里，就是一个 _ready 列表，存放 Task 对象的引用。
位置：在事件循环对象（用户态内存）中，由 Python 解释器维护，不在内核里。
作用：事件循环从就绪队列中取出任务，推进它的协程执行，直到遇到下一次 await。
类比：就绪队列 = “马上能跑的协程”的等待区，类似 OS 调度器的可运行队列，只是规模和规则简单很多。


立即任务、定时器、IO就绪 —— 本质都是内存里的任务集合
类型	含义	数据结构	触发条件
立即任务	马上可以推进的协程	普通队列（FIFO）	刚创建的 Task、上一次执行后已就绪的 Task
定时器	在未来某个时刻才恢复的协程	小根堆（按时间排序）	当前时间 >= 设定唤醒时间
IO 就绪	正在等待 socket/FD 的协程	由 IO 多路复用器维护的集合	对应 FD 可读/可写
定时器堆：例如调用 await asyncio.sleep(1)，事件循环会算出唤醒的时间戳，把 (唤醒时间, 协程引用) 放进堆。
IO 就绪集合：不是 Python 自己维护，而是交给内核的多路复用器（epoll/kqueue/IOCP）管理，等内核告诉事件循环“这个 FD 有数据了”再推进协程。


注册到多路复用器
Python 通过 selectors 模块调用底层系统调用（Linux 下是 epoll_ctl）：
系统调用：用户态 → 内核态（切换到内核栈）
内核在 epoll 对象中记录：“这个 FD 上的可读/可写事件”
当网卡、磁盘、驱动等触发中断 → 内核标记该 FD 为就绪
当事件循环调用 epoll_wait 时，内核扫描就绪集合，把 FD 列表返回给用户态。


协程在内存中是什么
在 CPython 中，async def 定义的协程是一个 PyCoroObject（C 结构体），包含：
协程函数的字节码指令指针（相当于程序计数器 PC）
局部变量（保存在栈帧对象中）
当前暂停位置（await 时保存）
引用的闭包变量
当你 await 时，协程会把当前执行位置和局部变量保存到内存对象里，这样下次恢复时从中间继续。


Task 是协程的运行容器
Task（_asyncio.Task）除了持有协程引用，还维护：
状态（PENDING、RUNNING、DONE、CANCELLED）
回调列表（协程完成后触发）
异常信息（如执行中抛出的异常）
状态机 = 用枚举值 + 执行路径来描述任务的生命周期：
PENDING → RUNNING → (DONE or CANCELLED)
当协程 await 一个阻塞点 → Task 状态变成挂起，事件循环不再推进它，直到条件就绪（定时/IO）。
条件就绪 → Task 重新加入就绪队列 → 状态回到 RUNNING。



从 CPU 视角看 “await” → “事件循环调度” 的全过程
1,协程执行到 await some_io()
解释器执行到 YIELD_FROM 字节码，把当前协程的指令位置（PC）、局部变量栈帧等保存在 PyCoroObject。
协程返回一个等待对象（Future/Task），告诉事件循环它需要一个条件（IO/定时器）才能继续。

2,事件循环收到等待对象
如果是 IO：调用 epoll_ctl 注册 FD 到多路复用器。
如果是定时器：把任务放进定时器堆。

3,事件循环空了就调用 epoll_wait
CPU 从用户态切到内核态等待 IO 或定时器到期（epoll_wait 的超时值由最近的定时器决定）。

4,内核返回就绪 FD
事件循环找到对应 Task，把它放进就绪队列。

5,事件循环推进 Task
从就绪队列取出 Task，把保存的指令位置、局部变量重新加载到协程对象。
解释器继续执行下一条字节码（相当于 CPU 执行“恢复上下文”的动作，但这是在 Python 解释器的虚拟机层面，不是硬件上下文切换）。


一个极简版 asyncio：只有事件循环（全局调度者）、就绪队列、定时器堆、IO 多路复用、Task/Future/协程。



3,事件循环空了就调用 epoll_wait
用户态 事件循环：
  计算最近定时器 deadline → timeout_ms
  -> 系统调用 epoll_wait(timeout_ms)
     ↓（用户态→内核态，切换到内核栈）
内核：
  把线程挂到 epoll 等待队列，schedule() 让出 CPU
  [期间：CPU去跑别的线程或idle]
  ① 有I/O到来 → 驱动/网络栈 → epoll就绪链表新增FD → 唤醒线程
  ② 或者timeout到点 → 唤醒线程（超时返回）
  返回到 epoll_wait → 携带(①事件列表 / ②超时0)
     ↑（内核态→用户态，恢复用户栈/寄存器）
用户态 事件循环：
  如果有FD事件 → 取出并把相关Task放回就绪队列
  如果超时 → 处理到点的定时器Task
  → 进入下一轮循环

epoll_wait 是阻塞系统调用，但阻塞的是线程，CPU 不会被占住。
定时器不是 epoll 的职责，事件循环用 timeout 把“等定时器”跟“等 I/O”统一起来。
唤醒要么来自I/O 中断路径，要么来自内核定时器到点（或用户层用 timerfd 伪装成 I/O 事件）。
